# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s7E9rqoQ0Iq9el5QzVDRuJEHly8w_lUb
"""

# =========================
# 0) Montar Drive e importar librerías
# =========================
from google.colab import drive, data_table
drive.mount('/content/drive')

import pandas as pd
import matplotlib.pyplot as plt

data_table.enable_dataframe_formatter()

# =========================
# 1) Cargar CSV con encodings alternativos
# =========================
companies = "/content/drive/MyDrive/Bootcamp Análisis de Datos/Datos Clase 1/sp500_companies.csv"


df = pd.read_csv(companies, encoding=enc)



# =========================
# 2) Info básica
# =========================
print("\n=== Info del DataFrame ===")
print(df.info())

print("Dimensiones:", df.shape)
display(df.head())

print("\n=== Nulos por columna ===")
print(df.isna().sum())

# Creamos una copia de df para mostrarlo más limpio
#df_display = df.copy()

# Acortamos la columna 'Longbusinesssummary' a 100 caracteres
#if "Longbusinesssummary" in df_display.columns:
  #  df_display["Longbusinesssummary"] = df_display["Longbusinesssummary"].astype(str).str.slice(0, 10) + "..."

# Ahora mostramos esta versión resumida
#df_display.head(10)

# =========================
# 1) Cargar CSV del índice S&P 500
# =========================
index_path = "/content/drive/MyDrive/Bootcamp Análisis de Datos/Datos Clase 1/sp500_index.csv"

for enc in ["utf-8", "latin1", "utf-8-sig"]:
    try:
        idx = pd.read_csv(index_path, encoding=enc)
        print(f"✅ Archivo cargado con encoding: {enc}")
        break
    except Exception as e:
        last_err = e
else:
    raise RuntimeError(f"No se pudo leer el CSV. Último error: {last_err}")

print("Dimensiones:", idx.shape)
display(idx.head())

# =========================
# 2) Parseo de fecha y preparación
# =========================
idx["Date"] = pd.to_datetime(idx["Date"], errors="coerce")
idx = idx.dropna(subset=["Date"]).sort_values("Date").reset_index(drop=True)
idx = idx[["Date", "S&P500"]].rename(columns={"S&P500": "Price"}).copy()

print("\n=== Info del DataFrame (Index) ===")
print(idx.info())
print("\n=== Nulos por columna ===")
print(idx.isna().sum())

display(idx.head())

# =========================
# 3) Evolución histórica
# =========================
plt.figure(figsize=(10,6))
plt.plot(idx["Date"], idx["Price"])
plt.title("S&P 500 - Evolución histórica")
plt.xlabel("Fecha")
plt.ylabel("Nivel del índice")
plt.grid(True, alpha=0.3)
plt.show()

# =========================

# =========================
# 0) Si aún no existe 'summary', lo calculamos (versión robusta)
# =========================
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Usa tus propias rutas si no tienes 'stocks' en memoria
try:
    stocks
except NameError:
    from google.colab import drive, data_table
    drive.mount('/content/drive')
    data_table.enable_dataframe_formatter()

    stocks_path = "/content/drive/MyDrive/Bootcamp Análisis de Datos/Datos Clase 1/sp500_stocks.csv"
    for enc in ["utf-8", "latin1", "utf-8-sig"]:
        try:
            stocks = pd.read_csv(stocks_path, encoding=enc)
            print(f"✅ Archivo cargado con encoding: {enc}")
            break
        except Exception as e:
            last_err = e
    else:
        raise RuntimeError(f"No se pudo leer el CSV. Último error: {last_err}")

    stocks["Date"] = pd.to_datetime(stocks["Date"], errors="coerce")
    for col in ["Open", "High", "Low", "Close", "Adj Close"]:
        if col in stocks.columns:
            stocks[col] = pd.to_numeric(stocks[col], errors="coerce")
    stocks = stocks.dropna(subset=["Date"]).sort_values(["Symbol","Date"]).reset_index(drop=True)

def max_min_safe(group: pd.DataFrame) -> pd.Series:
    valid_high = group["High"].notna()
    valid_low  = group["Low"].notna()
    if valid_high.any():
        max_pos   = group.loc[valid_high, "High"].idxmax()
        max_price = group.loc[max_pos, "High"]
        max_date  = group.loc[max_pos, "Date"]
    else:
        max_price = np.nan
        max_date  = pd.NaT
    if valid_low.any():
        min_pos   = group.loc[valid_low, "Low"].idxmin()
        min_price = group.loc[min_pos, "Low"]
        min_date  = group.loc[min_pos, "Date"]
    else:
        min_price = np.nan
        min_date  = pd.NaT
    return pd.Series({
        "Max_Price": max_price, "Max_Date": max_date,
        "Min_Price": min_price, "Min_Date": min_date
    })

summary = (
    stocks.groupby("Symbol", group_keys=False)
          .apply(max_min_safe)
          .reset_index()
          .dropna(subset=["Max_Date","Min_Date"], how="all")   # deja símbolos con al menos un extremo
)

# =========================
# 1) Pasar a formato largo para graficar (una fila por extremo)
# =========================
max_df = summary[["Symbol","Max_Date","Max_Price"]].dropna().rename(
    columns={"Max_Date":"Date","Max_Price":"Price"}
)
max_df["Extremo"] = "Máximo"

min_df = summary[["Symbol","Min_Date","Min_Price"]].dropna().rename(
    columns={"Min_Date":"Date","Min_Price":"Price"}
)
min_df["Extremo"] = "Mínimo"

extremos = pd.concat([max_df, min_df], ignore_index=True)
extremos = extremos.sort_values("Date")

print("Extremos (muestra):")
display(extremos.head(10))

# =========================
# 2) Gráfica: Fecha (X) vs Precio (Y) de los extremos por símbolo
# =========================
plt.figure(figsize=(12,6))

# Dos nubes: máximos y mínimos
ext_max = extremos[extremos["Extremo"]=="Máximo"]
ext_min = extremos[extremos["Extremo"]=="Mínimo"]

plt.scatter(ext_max["Date"], ext_max["Price"], marker="^", s=50, label="Máximos")
plt.scatter(ext_min["Date"], ext_min["Price"], marker="v", s=50, label="Mínimos")

plt.title("S&P 500 Stocks – Fechas y valores de máximos y mínimos por símbolo")
plt.xlabel("Fecha")
plt.ylabel("Precio (High/Low)")
plt.grid(alpha=0.3)
plt.legend()
plt.tight_layout()
plt.show()

# =========================
# 3) (Opcional) Etiquetas para un subconjunto (para no saturar)
# =========================
# Anota los símbolos más extremos (top 15 por precio máximo y mínimo)
to_label = pd.concat([
    ext_max.nlargest(15, "Price"),
    ext_min.nsmallest(15, "Price")
])

plt.figure(figsize=(12,6))
plt.scatter(ext_max["Date"], ext_max["Price"], marker="^", s=40, label="Máximos")
plt.scatter(ext_min["Date"], ext_min["Price"], marker="v", s=40, label="Mínimos")

for _, row in to_label.iterrows():
    plt.annotate(row["Symbol"],
                 (row["Date"], row["Price"]),
                 xytext=(5,5), textcoords="offset points", fontsize=8)

plt.title("S&P 500 Stocks – Extremos con etiquetas (subset)")
plt.xlabel("Fecha")
plt.ylabel("Precio (High/Low)")
plt.grid(alpha=0.3)
plt.legend()
plt.tight_layout()
plt.show()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# =========================
# 1) Cargar archivo de compañías
# =========================
companies_path = "/content/drive/MyDrive/Bootcamp Análisis de Datos/Datos Clase 1/sp500_companies.csv"
companies = pd.read_csv(companies_path, encoding="utf-8")

# Tomar las primeras 30 compañías
top30 = companies.head(30)
symbols_top30 = top30["Symbol"].unique().tolist()
print(f"Usando {len(symbols_top30)} símbolos (primeras 30 compañías).")

# =========================
# 2) Cargar histórico de stocks
# =========================
stocks_path = "/content/drive/MyDrive/Bootcamp Análisis de Datos/Datos Clase 1/sp500_stocks.csv"
stocks = pd.read_csv(stocks_path, encoding="utf-8")

stocks["Date"] = pd.to_datetime(stocks["Date"], errors="coerce")
for col in ["Open","High","Low","Close","Adj Close"]:
    stocks[col] = pd.to_numeric(stocks[col], errors="coerce")

stocks = stocks.dropna(subset=["Date"]).sort_values(["Symbol","Date"]).reset_index(drop=True)

# Filtrar solo primeras 30 compañías
stocks_30 = stocks[stocks["Symbol"].isin(symbols_top30)].copy()

# =========================
# 3) Calcular máximos y mínimos históricos
# =========================
def max_min_safe(group):
    valid_high = group["High"].notna()
    valid_low  = group["Low"].notna()
    if valid_high.any():
        max_pos = group.loc[valid_high, "High"].idxmax()
        max_price, max_date = group.loc[max_pos, ["High","Date"]]
    else:
        max_price, max_date = np.nan, pd.NaT
    if valid_low.any():
        min_pos = group.loc[valid_low, "Low"].idxmin()
        min_price, min_date = group.loc[min_pos, ["Low","Date"]]
    else:
        min_price, min_date = np.nan, pd.NaT
    return pd.Series({"Max_Price":max_price,"Max_Date":max_date,
                      "Min_Price":min_price,"Min_Date":min_date})

summary_30 = (
    stocks_30.groupby("Symbol", group_keys=False)
             .apply(max_min_safe)
             .reset_index()
)

# =========================
# 4) Preparar extremos para gráfica
# =========================
max_df = summary_30[["Symbol","Max_Date","Max_Price"]].dropna().rename(
    columns={"Max_Date":"Date","Max_Price":"Price"}
)
max_df["Extremo"] = "Máximo"

min_df = summary_30[["Symbol","Min_Date","Min_Price"]].dropna().rename(
    columns={"Min_Date":"Date","Min_Price":"Price"}
)
min_df["Extremo"] = "Mínimo"

extremos = pd.concat([max_df, min_df], ignore_index=True).sort_values("Date")

# =========================
# 5) Gráfica global
# =========================
plt.figure(figsize=(12,6))
plt.scatter(extremos.loc[extremos["Extremo"]=="Máximo","Date"],
            extremos.loc[extremos["Extremo"]=="Máximo","Price"],
            marker="^", s=60, label="Máximos")
plt.scatter(extremos.loc[extremos["Extremo"]=="Mínimo","Date"],
            extremos.loc[extremos["Extremo"]=="Mínimo","Price"],
            marker="v", s=60, label="Mínimos")

plt.title("Máximos y mínimos históricos – Primeras 30 compañías")
plt.xlabel("Fecha")
plt.ylabel("Precio (High/Low)")
plt.grid(alpha=0.3)
plt.legend()
plt.show()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# =========================
# 1) Cargar archivo de compañías
# =========================
companies_path = "/content/drive/MyDrive/Bootcamp Análisis de Datos/Datos Clase 1/sp500_companies.csv"
companies = pd.read_csv(companies_path, encoding="utf-8")

# Tomar las primeras 30 compañías
top30 = companies.head(30)
symbols_top30 = top30["Symbol"].unique().tolist()
print(f"Usando {len(symbols_top30)} símbolos (primeras 30 compañías).")

# =========================
# 2) Cargar histórico de stocks
# =========================
stocks_path = "/content/drive/MyDrive/Bootcamp Análisis de Datos/Datos Clase 1/sp500_stocks.csv"
stocks = pd.read_csv(stocks_path, encoding="utf-8")

stocks["Date"] = pd.to_datetime(stocks["Date"], errors="coerce")
for col in ["Open","High","Low","Close","Adj Close"]:
    stocks[col] = pd.to_numeric(stocks[col], errors="coerce")

stocks = stocks.dropna(subset=["Date"]).sort_values(["Symbol","Date"]).reset_index(drop=True)

# Filtrar solo primeras 30 compañías
stocks_30 = stocks[stocks["Symbol"].isin(symbols_top30)].copy()

# =========================
# 3) Calcular máximos y mínimos históricos
# =========================
def max_min_safe(group):
    valid_high = group["High"].notna()
    valid_low  = group["Low"].notna()
    if valid_high.any():
        max_pos = group.loc[valid_high, "High"].idxmax()
        max_price, max_date = group.loc[max_pos, ["High","Date"]]
    else:
        max_price, max_date = np.nan, pd.NaT
    if valid_low.any():
        min_pos = group.loc[valid_low, "Low"].idxmin()
        min_price, min_date = group.loc[min_pos, ["Low","Date"]]
    else:
        min_price, min_date = np.nan, pd.NaT
    return pd.Series({"Max_Price":max_price,"Max_Date":max_date,
                      "Min_Price":min_price,"Min_Date":min_date})

summary_30 = (
    stocks_30.groupby("Symbol", group_keys=False)
             .apply(max_min_safe)
             .reset_index()
)

# =========================
# 4) Preparar extremos para gráfica
# =========================
max_df = summary_30[["Symbol","Max_Date","Max_Price"]].dropna().rename(
    columns={"Max_Date":"Date","Max_Price":"Price"}
)
max_df["Extremo"] = "Máximo"

min_df = summary_30[["Symbol","Min_Date","Min_Price"]].dropna().rename(
    columns={"Min_Date":"Date","Min_Price":"Price"}
)
min_df["Extremo"] = "Mínimo"

extremos = pd.concat([max_df, min_df], ignore_index=True).sort_values("Date")

# =========================
# 5) Gráfica global con etiquetas
# =========================
plt.figure(figsize=(14,7))
plt.scatter(extremos.loc[extremos["Extremo"]=="Máximo","Date"],
            extremos.loc[extremos["Extremo"]=="Máximo","Price"],
            marker="^", s=80, color="green", label="Máximos")
plt.scatter(extremos.loc[extremos["Extremo"]=="Mínimo","Date"],
            extremos.loc[extremos["Extremo"]=="Mínimo","Price"],
            marker="v", s=80, color="red", label="Mínimos")

# Añadir etiquetas
for _, row in extremos.iterrows():
    plt.annotate(row["Symbol"],
                 (row["Date"], row["Price"]),
                 textcoords="offset points",
                 xytext=(5,5), ha="left", fontsize=8, alpha=0.8)

plt.title("Máximos y mínimos históricos – Primeras 30 compañías (con etiquetas)")
plt.xlabel("Fecha")
plt.ylabel("Precio (High/Low)")
plt.grid(alpha=0.3)
plt.legend()
plt.tight_layout()
plt.show()